{"randomArticles":[{"articleTitle":"代码雨效果","articleAbstractText":"简单的代码雨效果 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #bg { background-color: #222222; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;canvas id=\"bg\"&gt;&lt;/canvas&gt; &lt;/body&gt; &lt;script&gt; // 获取 canvas 元素 const cvs = document.getElementById('bg') // 获取窗口尺寸 const width = window.innerWidth * devicePixelRatio, height = wind....","articleStatus":0,"articlePermalink":"/articles/2025/07/24/1753367171022.html","articleImg1URL":"https://b3logfile.com/bing/20250624.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"TypeScript进阶","articleAbstractText":"ts进阶 /*** * 1.函数重载 */ // 重载签名 function add(a: number, b: number): number; function add(a: string, b: string): string; // 实现签名 function add(a: number | string, b: number | string): number | string { if (typeof a === 'number' &amp;&amp; typeof b === 'number') { return a + b; } else if (typeof a === 'string' &amp;&amp; typeof b === 'string') { return a + b; } // 处理不兼容的类型组合（编译时不会到这里，因为重载签名已经限制了参数类型） throw new Error('参数类型不匹配'); } // 使用 const numResult = add(1, 2); // 类型为 number const strResult = add(....","articleStatus":0,"articlePermalink":"/articles/2025/08/18/1755525205278.html","articleImg1URL":"https://b3logfile.com/bing/20200823.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"将ES6构造函数转换为ES5","articleAbstractText":"1. 根据下面 ES6 构造函数的书写方式，要求写出 ES5 的 class Example { &nbsp;constructor(name) { &nbsp; &nbsp;this.name = name; } &nbsp;init() { &nbsp; &nbsp;const fun = () =&gt; { console.log(this.name) } &nbsp; &nbsp;fun(); } } const e = new Example('Hello'); e.init();   参考答案： function Example(name) { &nbsp; 'use strict'; &nbsp; if (!new.target) { &nbsp; &nbsp; &nbsp; &nbsp;throw new TypeError('Class constructor cannot be invoked without new'); &nbsp; } &nbsp; this.name = name; } Object.defineProperty(Example.proto....","articleStatus":0,"articlePermalink":"/articles/2025/08/02/1754101916959.html","articleImg1URL":"https://b3logfile.com/bing/20220322.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"关于vue2中的computed计算属性","articleAbstractText":"面试题：computed和methods有什么区别  标准而浅显的回答   在使用时，computed当做属性使用，而methods则当做方法调用 computed可以具有getter和setter，因此可以赋值，而methods不行 computed无法接收多个参数，而methods可以 computed具有缓存，而methods没有   更接近底层原理的回答  vue对methods的处理比较简单，只需要遍历methods配置中的每个属性，将其对应的函数使用bind绑定当前组件实例后复制其引用到组件实例中即可 而vue对computed的处理会稍微复杂一些。 当组件实例触发生命周期函数beforeCreate后，它会做一系列事情，其中就包括对computed的处理 它会遍历computed配置中的所有属性，为每一个属性创建一个Watcher对象，并传入一个函数，该函数的本质其实就是computed配置中的getter，这样一来，getter运行过程中就会收集依赖 但是和渲染函数不同，为计算属性创建的Watcher不会立即执行，因为要考虑到该计算属性是否会被渲染函数使用，如果没有使用....","articleStatus":0,"articlePermalink":"/articles/2024/06/27/1719457607161.html","articleImg1URL":"https://b3logfile.com/bing/20201108.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"}]}